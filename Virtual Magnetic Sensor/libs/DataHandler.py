from __future__ import annotations
import copy
import numpy as np
import h5py as h5
import configparser
from typing import List, Dict, Any
import importlib.util
import os
from pathlib import Path
import string
from time import ctime

from libs.elements.SimParams import SimParams
from libs.elements.Component import Component
from libs.elements.Magnet import Magnet
from libs.elements.Sensor import Sensor
from libs.elements.components.Gear import Gear
from libs.elements.components.EvoGear import EvoGear
from libs.elements.components.GearRack import GearRack
from libs.elements.components.Shaft import Shaft
from libs.elements.magnets.CuboidMagnet import CuboidMagnet
from libs.elements.magnets.RodMagnet import RodMagnet
from libs.elements.magnets.UniField import UniField
from libs.elements.sensors.GMRSensor import GMRSensor
from libs.elements.sensors.FieldRecorder import FieldRecorder
from libs.elements.sensors.HallSensor import HallSensor


class DataHandler:
    """Objects of this class hold both the simulation parameters and the measurement 
    data generated by the simulation. The class also provides methods to save and
    load this data from/to file.

    :param objects: List containing all instances of classes in the simulation with parameters.
    :type objects: List[any]
    """

    objects: List[any]
    filepath: Path

    def __init__(self,
                 objects: List[any] = list(),
                 filepath: Path = Path('.')) -> None:
        """Constructor method."""

        self.objects = objects
        self.filepath = filepath

    @classmethod
    def template(cls):
        """Initialize the simulation and File parameters when no initial setup file is found.
        """

        return cls([SimParams.template()])

    def deploy_dict(self, dictionary: Dict[str, any]):
        """Deploy the information stored in a dictionary to the objects list.

        :param dictionary: Dictionary storing the simulation objects.
        :type: Dict[str, any]
        """
        self.objects.clear()
        
        bool=False
        for tkey in enumerate(list(dictionary.keys())):
            if "SimParams" in tkey[1]:
                if "t" in dictionary[tkey[1]]:
                    bool=True
                    
        for key in dictionary:
            if key[-1].isnumeric():
                num = key.lstrip(string.ascii_letters+string.punctuation)
                key = key.rstrip(string.digits+string.punctuation)
            else:
                num = ''
            if key in globals():
                if hasattr(globals()[key], 'from_dict'):
                    self.objects.append(
                        globals()[key].from_dict(dictionary[key+num]))
                    if bool==True:
                        if isinstance(self.objects[-1], EvoGear):
                            if hasattr(self.objects[-1], "damage_parameter_dict") and "tooth_side" in self.objects[-1].damage_parameter_dict:
                                encoding = 'utf-8'
                                self.objects[-1].damage_parameter_dict["tooth_side"] = str(self.objects[-1].damage_parameter_dict["tooth_side"], encoding)

    def load_h5(self, path: Path) -> None:
        """Method changes the object list based on data from a HDF5 file.

        :param path: Path to the file.
        :type path: Path
        """

        def rec_load_dict(h5file: h5.File, path_: str) -> Dict[str, any]:
            """Loads a HDF5 file recursively and returns a dict.

            :param h5file: HDF5 File.
            :type h5file: h5py.File
            :param path_: File path.
            :type path_: str

            :return: A dictionary of the data in the HDF5 file.
            :rtype: Dict[str, any]
            """

            ans: Dict[str, any] = dict()
            for key, item in h5file[path_].items():
                if isinstance(item, h5._hl.dataset.Dataset):
                    ans[key] = item[()]
                elif isinstance(item, h5._hl.group.Group):
                    ans[key] = rec_load_dict(h5file, path_ + key + '/')
            return ans

        self.filepath = Path(path.parent.as_posix(), path.stem)

        try:
            with h5.File(path.as_posix(), 'r') as file:
                data_dict = rec_load_dict(file, '/')
            file.close()
        except FileNotFoundError:
            data_dict = dict()

        self.deploy_dict(data_dict)

        if self.sim_params() is None:
            self.objects.append(SimParams.template())

    def load_py(self, path: Path) -> List[DataHandler]:
        """Method changes the object list based on data from a python file.

        :param path: Path to the python file.
        :type path: Path
        """
        self.filepath = Path(path.parent.as_posix(), path.stem)
        module: str = path.name
        spec = importlib.util.spec_from_file_location(module, path.as_posix())
        setup = importlib.util.module_from_spec(spec)

        try:
            spec.loader.exec_module(setup)
        except FileNotFoundError:
            pass

        data_stack: List[DataHandler] = list()
        series = None
        sizes = {}

        self.deploy_dict(setup.__dict__)
        for obj in self.objects:
            if hasattr(obj, 'convert_to_si'):
                obj.convert_to_si()

        for key, value in setup.__dict__.items():
            if key.lower() == "series":
                series = value
                for s_key, s_value in series.items():
                    temp_dictionary = s_value
                    while isinstance(temp_dictionary, dict):
                        iter_keys = list(temp_dictionary.keys())
                        if all(isinstance(temp_dictionary[k], dict) for k in iter_keys):
                            temp_dictionary = temp_dictionary[iter_keys[0]]
                        else:
                            sizes[s_key] = max(len(list(temp_dictionary[k])) for k in iter_keys)
                            break

        if self.sim_params() is None:
            self.objects.append(SimParams.template())

        data_stack.append(self)
        if series:
            if self.check_series(series):
                max_size = max(sizes.values())
                data_stack = [copy.deepcopy(element) for element in data_stack for _ in range(max_size)]

                for idx in range(max_size):
                    for s_key, values in series.items():
                        if s_key[-1].isnumeric():
                            key_num = int(s_key[-1])
                            s_key = s_key[:-1]
                        else:
                            key_num = 0

                        data_num = 0
                        for obj in data_stack[idx].objects:
                            if obj.__class__.__name__ == s_key:
                                if data_num == key_num:
                                    for attr, value in values.items():
                                        if isinstance(obj, EvoGear) and isinstance(value, dict):
                                            for inner_key, inner_value in value.items():
                                                value_dict = inner_value[idx] if idx < len(inner_value) else inner_value[-1]
                                                obj.damage_parameter_dict.update({inner_key: value_dict})
                                        else:
                                            value_dict = value[idx] if idx < len(value) else value[-1]
                                            if hasattr(obj, attr):
                                                setattr(obj, attr, value_dict)
                                else:
                                    data_num += 1

        return data_stack


    def load_ini(self, path: Path) -> None:
        """Method changes the object list based on data from a *.ini file.

        :param path: Path to the *.ini file.
        :type path: Path
        """

        self.filepath = Path(path.parent.as_posix(), path.stem)

        file = configparser.ConfigParser()
        file.read(path.as_posix())

        str_dict = {section: dict(file.items(section))
                    for section in file.sections()}
        data_dict = DataHandler.convert_dict(str_dict)

        self.deploy_dict(data_dict)
        for obj in self.objects:
            if hasattr(obj, 'convert_to_si'):
                obj.convert_to_si()

        if self.sim_params() is None:
            self.objects.append(SimParams.template())

    def to_dict(self) -> Dict[str, any]:
        """Method builds a dictionary of all meta and measurement data.

        :return: Dictionary with all data.
        :rtype: Dict[str, any]
        """

        dictionary: Dict[str, any] = dict()

        for obj in self.objects:
            key: str = str(type(obj).__name__)
            num: int = 0
            while key + str(num) in dictionary:
                num += 1
            if hasattr(obj, "to_dict"):
                dictionary[key + str(num)] = obj.to_dict()

        return dictionary

    def gui_dict(self) -> Dict[str, any]:
        """Method builds a dictionary of all meta and measurement data.

        :return: Dictionary with all data.
        :rtype: Dict[str, any]
        """

        dictionary: Dict[str, any] = dict()

        for obj in self.objects:
            key: str = str(type(obj).__name__)
            num: int = 0
            while key + str(num) in dictionary:
                num += 1
            if hasattr(obj, "gui_dict"):
                dictionary[key + str(num)] = obj.gui_dict()

        return dictionary

    @staticmethod
    def convert_dict(dictionary: Dict[str, str]):
        """Converts a dictionary with strings as values to the same dictionary with int, float, bool and
            np.ndarray values.

        :param dictionary: Dictionary with strings only.
        :type dictionary: Dict[str, dict]
        :return: Dictionary with int, float, bool and np.ndarray values.
        :rtype: Dict[str, dict]
        """

        def isfloat(element: any) -> bool:
            """Method checks if a string is convertible to float.

            :param element: Possible float value.
            :type element: any

            :return: True when element is convertible to float, false otherwise.
            :rtype: bool
            """

            if element is None:
                return False
            try:
                float(element)
                return True
            except ValueError:
                return False

        converted_dict: Dict[str, any] = dict()

        for key, value in dictionary.items():
            if isinstance(value, dict):
                converted_dict[key] = DataHandler.convert_dict(value)
            else:
                value = value.split('#')[0]
                if value.isnumeric():
                    converted_dict[key] = int(value)
                elif isfloat(value):
                    converted_dict[key] = float(value)
                elif value.lower() == 'true':
                    converted_dict[key] = True
                elif value.lower() == 'false':
                    converted_dict[key] = False
                elif '[' in value or ']' in value:
                    numpy_arrays = list()
                    if '\n' in value:
                        string_arrays = value.split(']\n[')
                    else:
                        string_arrays = value.split('][')
                    for array in string_arrays:
                        numpy_arrays.append(np.fromstring(
                            array.strip().strip('[]'), sep=' '))
                    converted_dict[key] = np.squeeze(
                        [array for array in numpy_arrays])
                else:
                    converted_dict[key] = value

        return converted_dict

    def save_py(self) -> bool:
        try:
            if not os.path.exists(self.filepath.parent):
                os.makedirs(self.filepath.parent)

            # Convert ndarray in dict to list
            data_dict = self.gui_dict()
            for obj, obj_dict in data_dict.items():
                if isinstance(obj_dict, dict):
                    for key, val in obj_dict.items():
                        if isinstance(val, np.ndarray):
                            data_dict[obj][key] = val.tolist()

            import json
            with open(self.filepath.with_suffix(".py"), 'w') as file:
                json.dump(data_dict, file, indent=4)

            return True
        except IOError:
            return False

    def save_ini(self) -> bool:
        config = configparser.ConfigParser()
        config.read_dict(self.gui_dict())

        try:
            if not os.path.exists(self.filepath.parent):
                os.makedirs(self.filepath.parent)

            with open(self.filepath.with_suffix(".ini"), 'w') as file:
                config.write(file)

            file.close()

            return True
        except IOError:
            return False

    def save_h5(self) -> bool:
        """Outputs the parameters and measurement data held by the object to a specified file.

        :return: True when the process is successful, false otherwise.
        :rtype: bool
        """

        def rec_save_dict(h5file: h5.File, filename: str, dictionary: Dict[str, any]) -> None:
            """Saves a python dictionary recursively as group to a HDF5 file.

            :param h5file: HDF5 file.
            :type h5file: h5py.File
            :param filename: Name of the save file.
            :type filename: str
            :param dictionary: Dictionary which gets saved in the file.
            :type dictionary: Dict[str, any]
            """

            for key, item in dictionary.items():
                if isinstance(item, (np.ndarray, int, float, str, bytes, list, np.int32, np.float32, np.bool_)):
                    h5file[filename + key] = item
                elif isinstance(item, Path):
                    h5file[filename + key] = item.as_posix()
                elif isinstance(item, dict):
                    rec_save_dict(h5file, filename + key + '/', item)
                else:
                    print(key)
                    raise ValueError('Cannot save %s type' % type(item))

        try:
            if not os.path.exists(self.filepath.parent):
                os.makedirs(self.filepath.parent)

            with h5.File(self.filepath.with_suffix(".hdf5"), mode='w') as file:
                print("Saved at", ctime())
                rec_save_dict(file, '/', self.to_dict())

            file.close()

            return True
        except IOError:
            return False

    def update_objects(self, frames: List[any]) -> None:
        """The method updates the data contained in the object based on the current gui entries.
        """

        self.objects.clear()
        for frame in frames:
            if hasattr(frame, "get_parameters"):
                cls = globals()[frame.__class__.__name__.replace('Frame', '')]
                self.objects.append(cls(**frame.get_parameters()))
                if hasattr(self.objects[-1], 'convert_to_si'):
                    self.objects[-1].convert_to_si()
            elif hasattr(frame, "sub_frames"):
                for sub_frame in frame.sub_frames:
                    if hasattr(sub_frame, "get_parameters"):
                        cls = globals()[
                            sub_frame.__class__.__name__.replace('Frame', '')]
                        self.objects.append(cls(**sub_frame.get_parameters()))
                        if hasattr(self.objects[-1], 'convert_to_si'):
                            self.objects[-1].convert_to_si()
                        if hasattr(sub_frame, 'update_buttons'):
                            sub_frame.update_buttons(self.objects[-1])

    
    """ def check_series(series: Dict[str, Dict[str, List[float]]]):
        # Check for matching dimensions
        size = len(list(list(series.values())[0].values())[0])
        for value in list(series.values()):
            if type(value) == dict:
                for attr in list(value.values()):
                    if len(attr) != size:
                        return 0

        return 1 """
    
    @staticmethod
    def check_series(series: Dict[str, Any]) -> bool:
        """
        Checks if the dimensions of the entries match.

         :return: 1 if entries match, 0 otherwise.
         :rtype: int
        """
        def get_list_lengths(d: Dict[str, Any], lengths: List[int]) -> None:
            """
            Helper function to recursively collect the lengths of lists in the nested dictionary.
            
            :param d: Current dictionary to inspect.
            :param lengths: List to collect the lengths of found lists.
            """
            for value in d.values():
                if isinstance(value, dict):
                    get_list_lengths(value, lengths)
                elif isinstance(value, list) and all(isinstance(i, float) for i in value):
                    lengths.append(len(value))

        # Collect all list lengths
        list_lengths = []
        get_list_lengths(series, list_lengths)

        # Check if all collected list lengths are the same
        return len(set(list_lengths)) == 1 if list_lengths else True
    
    def components(self):
        """Method returns the objects of type Component in a list.

        :return: List of objects of type Component.
        :rtype: List[Component]
        """

        components_list = list()
        for obj in self.objects:
            if isinstance(obj, Component):
                components_list.append(obj)

        return components_list

    def magnets(self):
        """Method returns the objects of type Magnet or UniField in a list.

        :return: List of objects of type Magnet or UniField.
        :rtype: List[Union[Magnet, UniField]]
        """

        magnets_list = list()
        for obj in self.objects:
            if isinstance(obj, Magnet) or isinstance(obj, UniField):
                magnets_list.append(obj)

        return magnets_list

    def physical_magnets(self):
        """Method returns the objects of type Magnet in a list.

        :return: List of objects of type Magnet.
        :rtype: List[Magnet]
        """

        magnets_list = list()
        for obj in self.objects:
            if isinstance(obj, Magnet):
                magnets_list.append(obj)

        return magnets_list

    def uni_fields(self):
        """Method returns the objects of type UniField in a list.

        :return: List of objects of type UniField.
        :rtype: List[UniField]
        """

        magnets_list = list()
        for obj in self.objects:
            if isinstance(obj, UniField):
                magnets_list.append(obj)

        return magnets_list

    def sensors(self):
        """Method returns the objects of type Sensor or FieldRecorder in a list.

        :return: List of objects of type Sensor or FieldRecorder.
        :rtype: List[Union[Sensor, FieldRecorder]]
        """

        sensors_list = list()
        for obj in self.objects:
            if isinstance(obj, Sensor) or isinstance(obj, FieldRecorder):
                sensors_list.append(obj)

        return sensors_list

    def physical_sensors(self):
        """Method returns the objects of type Sensor in a list.

        :return: List of objects of type Sensor.
        :rtype: List[Sensor]
        """

        sensors_list = list()
        for obj in self.objects:
            if isinstance(obj, Sensor):
                sensors_list.append(obj)

        return sensors_list

    def gmr_sensors(self):
        """Method returns the objects of type GMRSensor in a list.

        :return: List of objects of type GMRSensor.
        :rtype: List[GMRSensor]
        """

        sensors_list = list()
        for obj in self.objects:
            if isinstance(obj, GMRSensor):
                sensors_list.append(obj)

        return sensors_list

    def field_recorders(self):
        """Method returns the objects of type FieldRecorder in a list.

        :return: List of objects of type FieldRecorder.
        :rtype: List[FieldRecorder]
        """

        sensors_list = list()
        for obj in self.objects:
            if isinstance(obj, FieldRecorder):
                sensors_list.append(obj)

        return sensors_list

    def sim_params(self):
        """Method returns the objects of type SimParams in a list.

        :return: Object in objects list of type SimParams.
        :rtype: SimParams
        """

        for obj in self.objects:
            if isinstance(obj, SimParams):
                return obj

        return None
